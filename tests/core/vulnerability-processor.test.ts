import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { promises as fs } from 'fs';
import { VulnerabilityProcessor } from '../../src/core/vulnerability-processor.js';
import { ParserRegistry } from '../../src/parsers/parser-registry.js';
import { IgnoreFilter } from '../../src/utils/ignore-filter.js';
import { ConfigLoader } from '../../src/utils/config-loader.js';
import { ExcelReporter } from '../../src/reporters/excel-reporter.js';
import { NotifierRegistry } from '../../src/notifiers/notifier-registry.js';
import { NotifyConfigLoader } from '../../src/utils/notify-config-loader.js';
import { ResultLogger } from '../../src/utils/result-logger.js';
import type {
  CliOptions,
  StandardVulnerability,
  VulnerabilitySummary,
  ProcessedVulnerability,
  VulnIgnoreRule,
  NotifierConfig,
} from '../../src/types.js';

// Mock all dependencies
vi.mock('fs', () => ({
  promises: {
    readFile: vi.fn(),
  },
}));

vi.mock('../../src/parsers/parser-registry.js');
vi.mock('../../src/utils/ignore-filter.js');
vi.mock('../../src/utils/config-loader.js');
vi.mock('../../src/reporters/excel-reporter.js');
vi.mock('../../src/notifiers/notifier-registry.js');
vi.mock('../../src/utils/notify-config-loader.js');
vi.mock('../../src/utils/result-logger.js');

describe('VulnerabilityProcessor', () => {
  let processor: VulnerabilityProcessor;
  let consoleLogSpy: any;
  let consoleErrorSpy: any;

  const mockOptions: CliOptions = {
    input: 'test-report.json',
    reporterTitle: 'Test Report',
    scanner: 'auto',
    verbose: false,
    detailsUrl: 'https://example.com/details',
    ignoreConfig: '.vuln-ignore.yml',
    notifyConfig: '.vuln-notify.yml',
    outputFile: 'test-output.xlsx',
    exitOnHighSeverity: true,
  };

  const mockVulnerabilities: StandardVulnerability[] = [
    {
      id: 'CVE-2023-12345',
      packageName: 'lodash',
      installedVersion: '4.17.20',
      fixedVersion: '4.17.21',
      severity: 'CRITICAL',
      title: 'Critical vulnerability in lodash',
      description: 'Remote code execution vulnerability',
      references: ['https://nvd.nist.gov/vuln/detail/CVE-2023-12345'],
    },
    {
      id: 'CVE-2023-67890',
      packageName: 'axios',
      installedVersion: '0.21.0',
      severity: 'HIGH',
      title: 'High severity vulnerability in axios',
      description: 'Information disclosure vulnerability',
    },
  ];

  const mockProcessedVulnerabilities: ProcessedVulnerability[] = [
    {
      ...mockVulnerabilities[0],
      isIgnored: false,
    },
    {
      ...mockVulnerabilities[1],
      isIgnored: true,
      ignoreReason: 'å·²ç¢ºèªç‚ºèª¤å ±',
    },
  ];

  const mockSummary: VulnerabilitySummary = {
    critical: { new: 1, ignored: 0, total: 1 },
    high: { new: 0, ignored: 1, total: 1 },
    medium: { new: 0, ignored: 0, total: 0 },
    low: { new: 0, ignored: 0, total: 0 },
  };

  const mockIgnoreRules: VulnIgnoreRule[] = [
    {
      cve: 'CVE-2023-67890',
      reason: 'å·²ç¢ºèªç‚ºèª¤å ±',
    },
  ];

  const mockNotifierConfigs: NotifierConfig[] = [
    {
      type: 'teams',
      enabled: true,
      config: {
        webhookUrl: 'https://example.com/webhook',
      },
    },
  ];

  beforeEach(() => {
    processor = new VulnerabilityProcessor();
    consoleLogSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

    // Reset all mocks
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('processReport', () => {
    let mockParserRegistry: any;
    let mockConfigLoader: any;
    let mockIgnoreFilter: any;
    let mockExcelReporter: any;
    let mockNotifyConfigLoader: any;
    let mockNotifierRegistry: any;
    let mockResultLogger: any;

    beforeEach(() => {
      // Setup default mocks
      vi.mocked(fs.readFile).mockResolvedValue(JSON.stringify({ test: 'data' }));

      mockParserRegistry = {
        detectParser: vi.fn().mockReturnValue({
          parser: { parseReport: vi.fn().mockReturnValue(mockVulnerabilities) },
          scannerType: 'trivy',
        }),
        getParser: vi.fn().mockReturnValue({
          parseReport: vi.fn().mockReturnValue(mockVulnerabilities),
        }),
        listAvailableParsers: vi.fn().mockReturnValue(['trivy']),
      };
      vi.mocked(ParserRegistry).mockImplementation(() => mockParserRegistry);

      mockConfigLoader = {
        loadConfig: vi.fn().mockResolvedValue({ rules: mockIgnoreRules }),
      };
      vi.mocked(ConfigLoader).mockImplementation(() => mockConfigLoader);

      mockIgnoreFilter = {
        processVulnerabilities: vi.fn().mockReturnValue(mockProcessedVulnerabilities),
        generateSummary: vi.fn().mockReturnValue(mockSummary),
      };
      vi.mocked(IgnoreFilter).mockImplementation(() => mockIgnoreFilter);

      mockExcelReporter = {
        generateReport: vi.fn().mockResolvedValue(undefined),
      };
      vi.mocked(ExcelReporter).mockImplementation(() => mockExcelReporter);

      mockNotifyConfigLoader = {
        loadNotifyConfig: vi.fn().mockResolvedValue({ notifiers: mockNotifierConfigs }),
      };
      vi.mocked(NotifyConfigLoader).mockImplementation(() => mockNotifyConfigLoader);

      mockNotifierRegistry = {
        sendNotifications: vi.fn().mockResolvedValue(undefined),
      };
      vi.mocked(NotifierRegistry).mockImplementation(() => mockNotifierRegistry);

      mockResultLogger = {
        logResults: vi.fn(),
        calculateTotals: vi.fn().mockReturnValue({ totalNew: 1 }),
      };
      vi.mocked(ResultLogger).mockImplementation(() => mockResultLogger);
    });

    it('should process vulnerability report successfully and return true', async () => {
      const mockSummaryNoHighSeverity: VulnerabilitySummary = {
        critical: { new: 0, ignored: 1, total: 1 },
        high: { new: 0, ignored: 0, total: 0 },
        medium: { new: 1, ignored: 0, total: 1 },
        low: { new: 0, ignored: 0, total: 0 },
      };

      mockResultLogger.calculateTotals.mockReturnValue({ totalNew: 1 });
      mockIgnoreFilter.generateSummary.mockReturnValue(mockSummaryNoHighSeverity);

      const result = await processor.processReport(mockOptions);

      expect(result).toBe(true);
      expect(consoleLogSpy).toHaveBeenCalledWith('ðŸ” é–‹å§‹è™•ç†æ¼æ´žæŽƒæå ±å‘Š...');
      expect(consoleLogSpy).toHaveBeenCalledWith('ðŸŽ‰ æ‰€æœ‰ä»»å‹™å®Œæˆ!');
    });

    it('should process vulnerability report with specified scanner', async () => {
      const optionsWithScanner = { ...mockOptions, scanner: 'trivy' };

      // Use a summary with no high severity vulnerabilities to avoid process.exit
      const mockSummaryNoHighSeverity: VulnerabilitySummary = {
        critical: { new: 0, ignored: 0, total: 0 },
        high: { new: 0, ignored: 0, total: 0 },
        medium: { new: 1, ignored: 0, total: 1 },
        low: { new: 0, ignored: 0, total: 0 },
      };

      mockResultLogger.calculateTotals.mockReturnValue({ totalNew: 1 });
      mockIgnoreFilter.generateSummary.mockReturnValue(mockSummaryNoHighSeverity);

      await processor.processReport(optionsWithScanner);

      expect(mockParserRegistry.getParser).toHaveBeenCalledWith('trivy');
      expect(consoleLogSpy).toHaveBeenCalledWith('ðŸ“‹ ä½¿ç”¨æŒ‡å®šçš„è§£æžå™¨: trivy');
    });

    it('should throw error for unsupported scanner type', async () => {
      const optionsWithInvalidScanner = { ...mockOptions, scanner: 'invalid' };

      const mockParserRegistry = {
        getParser: vi.fn().mockReturnValue(null),
        listAvailableParsers: vi.fn().mockReturnValue(['trivy']),
      };
      vi.mocked(ParserRegistry).mockImplementation(() => mockParserRegistry as any);

      await expect(processor.processReport(optionsWithInvalidScanner)).rejects.toThrow(
        'ä¸æ”¯æ´çš„æŽƒæå·¥å…·é¡žåž‹: invalidã€‚æ”¯æ´çš„é¡žåž‹: trivy',
      );
    });

    it('should return false when high severity vulnerabilities found and exitOnHighSeverity is true', async () => {
      const mockSummaryWithHighSeverity: VulnerabilitySummary = {
        critical: { new: 1, ignored: 0, total: 1 },
        high: { new: 1, ignored: 0, total: 1 },
        medium: { new: 0, ignored: 0, total: 0 },
        low: { new: 0, ignored: 0, total: 0 },
      };

      mockResultLogger.calculateTotals.mockReturnValue({ totalNew: 2 });
      mockIgnoreFilter.generateSummary.mockReturnValue(mockSummaryWithHighSeverity);

      const result = await processor.processReport(mockOptions);

      expect(result).toBe(false);
      expect(consoleLogSpy).toHaveBeenCalledWith('âš ï¸  è«‹æ³¨æ„: ç™¼ç¾é«˜åš´é‡æ€§æ¼æ´žï¼Œå»ºè­°ç«‹å³è™•ç†');
    });

    it('should return true when exitOnHighSeverity is false', async () => {
      const optionsWithNoExit = { ...mockOptions, exitOnHighSeverity: false };
      const mockSummaryWithHighSeverity: VulnerabilitySummary = {
        critical: { new: 1, ignored: 0, total: 1 },
        high: { new: 1, ignored: 0, total: 1 },
        medium: { new: 0, ignored: 0, total: 0 },
        low: { new: 0, ignored: 0, total: 0 },
      };

      mockResultLogger.calculateTotals.mockReturnValue({ totalNew: 2 });
      mockIgnoreFilter.generateSummary.mockReturnValue(mockSummaryWithHighSeverity);

      const result = await processor.processReport(optionsWithNoExit);

      expect(result).toBe(true);
      expect(consoleLogSpy).toHaveBeenCalledWith('âš ï¸  è«‹æ³¨æ„: ç™¼ç¾é«˜åš´é‡æ€§æ¼æ´žï¼Œå»ºè­°ç«‹å³è™•ç†');
    });

    it('should handle medium/low severity vulnerabilities', async () => {
      const mockSummaryWithMediumSeverity: VulnerabilitySummary = {
        critical: { new: 0, ignored: 0, total: 0 },
        high: { new: 0, ignored: 0, total: 0 },
        medium: { new: 1, ignored: 0, total: 1 },
        low: { new: 1, ignored: 0, total: 1 },
      };

      const mockResultLogger = {
        logResults: vi.fn(),
        calculateTotals: vi.fn().mockReturnValue({ totalNew: 2 }),
      };
      vi.mocked(ResultLogger).mockImplementation(() => mockResultLogger as any);

      const mockIgnoreFilter = {
        processVulnerabilities: vi.fn().mockReturnValue(mockProcessedVulnerabilities),
        generateSummary: vi.fn().mockReturnValue(mockSummaryWithMediumSeverity),
      };
      vi.mocked(IgnoreFilter).mockImplementation(() => mockIgnoreFilter as any);

      await processor.processReport(mockOptions);

      expect(consoleLogSpy).toHaveBeenCalledWith('â„¹ï¸  ç™¼ç¾ä¸­ä½Žåš´é‡æ€§æ¼æ´žï¼Œå»ºè­°å®šæœŸè™•ç†');
      expect(consoleLogSpy).toHaveBeenCalledWith('ðŸŽ‰ æ‰€æœ‰ä»»å‹™å®Œæˆ!');
    });

    it('should handle no new vulnerabilities', async () => {
      const mockSummaryWithNoNew: VulnerabilitySummary = {
        critical: { new: 0, ignored: 1, total: 1 },
        high: { new: 0, ignored: 1, total: 1 },
        medium: { new: 0, ignored: 0, total: 0 },
        low: { new: 0, ignored: 0, total: 0 },
      };

      const mockResultLogger = {
        logResults: vi.fn(),
        calculateTotals: vi.fn().mockReturnValue({ totalNew: 0 }),
      };
      vi.mocked(ResultLogger).mockImplementation(() => mockResultLogger as any);

      const mockIgnoreFilter = {
        processVulnerabilities: vi.fn().mockReturnValue(mockProcessedVulnerabilities),
        generateSummary: vi.fn().mockReturnValue(mockSummaryWithNoNew),
      };
      vi.mocked(IgnoreFilter).mockImplementation(() => mockIgnoreFilter as any);

      await processor.processReport(mockOptions);

      expect(consoleLogSpy).toHaveBeenCalledWith('âœ¨ æ­å–œ! æœªç™¼ç¾ä»»ä½•æ–°æ¼æ´ž');
      expect(consoleLogSpy).toHaveBeenCalledWith('ðŸŽ‰ æ‰€æœ‰ä»»å‹™å®Œæˆ!');
    });

    it('should skip notifications when no notifiers configured', async () => {
      const mockNotifyConfigLoader = {
        loadNotifyConfig: vi.fn().mockResolvedValue({ notifiers: [] }),
      };
      vi.mocked(NotifyConfigLoader).mockImplementation(() => mockNotifyConfigLoader as any);

      // Use a summary with no high severity vulnerabilities to avoid process.exit
      const mockSummaryNoHighSeverity: VulnerabilitySummary = {
        critical: { new: 0, ignored: 0, total: 0 },
        high: { new: 0, ignored: 0, total: 0 },
        medium: { new: 1, ignored: 0, total: 1 },
        low: { new: 0, ignored: 0, total: 0 },
      };

      const mockResultLogger = {
        logResults: vi.fn(),
        calculateTotals: vi.fn().mockReturnValue({ totalNew: 1 }),
      };
      vi.mocked(ResultLogger).mockImplementation(() => mockResultLogger as any);

      const mockIgnoreFilter = {
        processVulnerabilities: vi.fn().mockReturnValue(mockProcessedVulnerabilities),
        generateSummary: vi.fn().mockReturnValue(mockSummaryNoHighSeverity),
      };
      vi.mocked(IgnoreFilter).mockImplementation(() => mockIgnoreFilter as any);

      await processor.processReport(mockOptions);

      expect(consoleLogSpy).toHaveBeenCalledWith('â„¹ï¸ æœªé…ç½®é€šçŸ¥å™¨ï¼Œè·³éŽé€šçŸ¥ç™¼é€');
      expect(NotifierRegistry).not.toHaveBeenCalled();
    });

    it('should handle notification failures gracefully', async () => {
      const mockNotifierRegistry = {
        sendNotifications: vi.fn().mockRejectedValue(new Error('Notification failed')),
      };
      vi.mocked(NotifierRegistry).mockImplementation(() => mockNotifierRegistry as any);

      // Use a summary with no high severity vulnerabilities to avoid process.exit
      const mockSummaryNoHighSeverity: VulnerabilitySummary = {
        critical: { new: 0, ignored: 0, total: 0 },
        high: { new: 0, ignored: 0, total: 0 },
        medium: { new: 1, ignored: 0, total: 1 },
        low: { new: 0, ignored: 0, total: 0 },
      };

      const mockResultLogger = {
        logResults: vi.fn(),
        calculateTotals: vi.fn().mockReturnValue({ totalNew: 1 }),
      };
      vi.mocked(ResultLogger).mockImplementation(() => mockResultLogger as any);

      const mockIgnoreFilter = {
        processVulnerabilities: vi.fn().mockReturnValue(mockProcessedVulnerabilities),
        generateSummary: vi.fn().mockReturnValue(mockSummaryNoHighSeverity),
      };
      vi.mocked(IgnoreFilter).mockImplementation(() => mockIgnoreFilter as any);

      await processor.processReport(mockOptions);

      expect(consoleErrorSpy).toHaveBeenCalledWith('âŒ é€šçŸ¥ç™¼é€å¤±æ•—:', 'Notification failed');
      expect(consoleLogSpy).toHaveBeenCalledWith('ðŸŽ‰ æ‰€æœ‰ä»»å‹™å®Œæˆ!');
    });

    it('should handle file reading errors', async () => {
      vi.mocked(fs.readFile).mockRejectedValue(new Error('File not found'));

      await expect(processor.processReport(mockOptions)).rejects.toThrow('File not found');
    });

    it('should handle JSON parsing errors', async () => {
      vi.mocked(fs.readFile).mockResolvedValue('invalid json');

      await expect(processor.processReport(mockOptions)).rejects.toThrow();
    });

    it('should pass correct parameters to Excel reporter', async () => {
      // Use a summary with no high severity vulnerabilities to avoid process.exit
      const mockSummaryNoHighSeverity: VulnerabilitySummary = {
        critical: { new: 0, ignored: 0, total: 0 },
        high: { new: 0, ignored: 0, total: 0 },
        medium: { new: 1, ignored: 0, total: 1 },
        low: { new: 0, ignored: 0, total: 0 },
      };

      mockResultLogger.calculateTotals.mockReturnValue({ totalNew: 1 });
      mockIgnoreFilter.generateSummary.mockReturnValue(mockSummaryNoHighSeverity);

      await processor.processReport(mockOptions);

      expect(mockExcelReporter.generateReport).toHaveBeenCalledWith(
        {
          vulnerabilities: mockProcessedVulnerabilities,
          summary: mockSummaryNoHighSeverity,
          reportTitle: 'Test Report',
          detailsUrl: 'https://example.com/details',
        },
        expect.stringContaining('test-output.xlsx'),
      );
    });

    it('should pass correct parameters to notifier registry', async () => {
      // Use a summary with no high severity vulnerabilities to avoid process.exit
      const mockSummaryNoHighSeverity: VulnerabilitySummary = {
        critical: { new: 0, ignored: 0, total: 0 },
        high: { new: 0, ignored: 0, total: 0 },
        medium: { new: 1, ignored: 0, total: 1 },
        low: { new: 0, ignored: 0, total: 0 },
      };

      mockResultLogger.calculateTotals.mockReturnValue({ totalNew: 1 });
      mockIgnoreFilter.generateSummary.mockReturnValue(mockSummaryNoHighSeverity);

      await processor.processReport(mockOptions);

      expect(mockNotifierRegistry.sendNotifications).toHaveBeenCalledWith(
        {
          summary: mockSummaryNoHighSeverity,
          reportTitle: 'Test Report',
          detailsUrl: 'https://example.com/details',
        },
        mockNotifierConfigs,
      );
    });

    it('should initialize ResultLogger with verbose option', async () => {
      const verboseOptions = { ...mockOptions, verbose: true };

      // Use a summary with no high severity vulnerabilities to avoid process.exit
      const mockSummaryNoHighSeverity: VulnerabilitySummary = {
        critical: { new: 0, ignored: 0, total: 0 },
        high: { new: 0, ignored: 0, total: 0 },
        medium: { new: 1, ignored: 0, total: 1 },
        low: { new: 0, ignored: 0, total: 0 },
      };

      const mockResultLogger = {
        logResults: vi.fn(),
        calculateTotals: vi.fn().mockReturnValue({ totalNew: 1 }),
      };
      vi.mocked(ResultLogger).mockImplementation(() => mockResultLogger as any);

      const mockIgnoreFilter = {
        processVulnerabilities: vi.fn().mockReturnValue(mockProcessedVulnerabilities),
        generateSummary: vi.fn().mockReturnValue(mockSummaryNoHighSeverity),
      };
      vi.mocked(IgnoreFilter).mockImplementation(() => mockIgnoreFilter as any);

      await processor.processReport(verboseOptions);

      expect(ResultLogger).toHaveBeenCalledWith({ verbose: true });
    });

    it('should load ignore config from specified path', async () => {
      const customIgnoreConfig = { ...mockOptions, ignoreConfig: 'custom-ignore.yml' };

      // Use a summary with no high severity vulnerabilities to avoid process.exit
      const mockSummaryNoHighSeverity: VulnerabilitySummary = {
        critical: { new: 0, ignored: 0, total: 0 },
        high: { new: 0, ignored: 0, total: 0 },
        medium: { new: 1, ignored: 0, total: 1 },
        low: { new: 0, ignored: 0, total: 0 },
      };

      mockResultLogger.calculateTotals.mockReturnValue({ totalNew: 1 });
      mockIgnoreFilter.generateSummary.mockReturnValue(mockSummaryNoHighSeverity);

      await processor.processReport(customIgnoreConfig);

      expect(mockConfigLoader.loadConfig).toHaveBeenCalledWith('custom-ignore.yml');
    });

    it('should load notify config from specified path', async () => {
      const customNotifyConfig = { ...mockOptions, notifyConfig: 'custom-notify.yml' };

      // Use a summary with no high severity vulnerabilities to avoid process.exit
      const mockSummaryNoHighSeverity: VulnerabilitySummary = {
        critical: { new: 0, ignored: 0, total: 0 },
        high: { new: 0, ignored: 0, total: 0 },
        medium: { new: 1, ignored: 0, total: 1 },
        low: { new: 0, ignored: 0, total: 0 },
      };

      mockResultLogger.calculateTotals.mockReturnValue({ totalNew: 1 });
      mockIgnoreFilter.generateSummary.mockReturnValue(mockSummaryNoHighSeverity);

      await processor.processReport(customNotifyConfig);

      expect(mockNotifyConfigLoader.loadNotifyConfig).toHaveBeenCalledWith('custom-notify.yml');
    });
  });
});
